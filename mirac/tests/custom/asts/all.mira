
; --- 
; :brief memory (like static arrays in c)
; --- 
mem my_mem_1 10 ; of size = 10 bytes

func test_func {
	10 putu
}

; --- 
; :brief function (can be marked as inlined with 'inl' keyword before 'func' keyword)
; --- 
func my_func_1 {
	; code goes here...

	test_func

	1 as i64
	1 2 as i64 i32
	1 2 3 as i64 i32 i16
	1 2 3 4 as i64 i32 i16 i08

	; --- 
	; :brief branching blocks
	; --- 
	1 1 == if {
		; code goes here...
	}

	1 2 == if {
		; code goes here...
	} else {
		; code goes here...
	}

	1 2 == if {
		; code goes here...
	}
	2 2 == elif {
		; code goes here...
	}

	1 2 == if {
		; code goes here...
	}
	2 2 == elif {
		; code goes here...
	}
	else {
		; code goes here...
	}
	; --- 

	; --- 
	; :brief loop
	; --- 
	1 \+. 10 < loop {
		; code goes here...
		1 +
		\+. 10 <
	}

	; --- 
	; :brief let (binds stack values (copies) into a reserved buffer for easier work with multiple level of values)
	; --- 
	1 2 3 4 5
	let a b c d e {
		c as u64 putu
		a as u64 putu
		d as u64 putu
		b as u64 putu
		e as u64 putu
	}

	; --- 
	; :brief reg (binds stack values (copies) into a native registers for easier work with multiple level of values)
	; --- 
	1 2 3 4 5
	reg r0 r1 r2 r3 r4 {
		r1 as u64 putu
		r2 as u64 putu
		r3 as u64 putu
		r4 as u64 putu
		r5 as u64 putu
	}
}
